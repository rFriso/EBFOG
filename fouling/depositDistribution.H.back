// Need to find the i,j coordinate of the deposit. 
// This is a little bit tricky since the grid is a little bit streched somehow. 
// The only way that comes to my mind in order to have a safe and reliable way to 
//check wether the impact point is inside or outside the grid is the following
/*

  x-----------------------x
  |\			  |
  | \ 			  |
 /|\ o			  |
  | /			  |                
  |/ 			  | 
  x-----------------------x

The triangle build with the impact point (xyz+d/2*normalToTheFace) is such that
the normal to the face (computed using the direction provided by the only edge of the original
face involved in the calculation) points toward the same direction of the original face.


*/

// Parameter to evaluate the sign of the triangulation 
label  facetHit=0;
//need to compute the faceArea before
scalarField facetArea (deposits.size(),Zero); 
scalarField dotProds (deposits.size(),Zero); 

forAll(deposits,faceI)
{
    Info << "calculating centers and areas" << tab << faceI << endl;


    bool checkFace=false;
    label iter=0;
	

    //Area of the facets
    double 	faceCross[2][2];
    vector	aCr = auxGrid[facets[faceI][0]];
    vector	bCr = auxGrid[facets[faceI][2]];
    vector	pCr = auxGrid[facets[faceI][1]];
    vector	qCr = auxGrid[facets[faceI][3]];
  
    vector	center = Zero;

    double	rhs[2];

    scalar	detRhs;
    double 	detAij[2];

    // need to find cell center: using the relation for
    // the crossing of two segments.
    // CAREFUL: in 3D it may happen that the two segments are the same
    // due to an unluky projection. so test with the third equation of
    // the sistem.
    Info << "To check" <<  	aCr << tab   << pCr << tab <<
				bCr << tab   << qCr << endl;
	
    while ( !checkFace )
    {
    	    Info << "Attempt "<< iter   << endl;
//	if (iter<=1)
//	{
	
            faceCross[0][0]= aCr[iter]  - bCr[iter]; 
            faceCross[1][0]= aCr[iter+1]- bCr[iter+1];
            
//    Info << "To check New" <<  	aCr[iter] << tab   << bCr[iter] << tab
//    			   <<  	aCr[iter+1] << tab   << bCr[iter+1] << endl;
            faceCross[0][1]= qCr[iter]  - pCr[iter]; 
            faceCross[1][1]= qCr[iter+1]- pCr[iter+1];
            
            rhs[0] = qCr[iter]  - bCr[iter]; 
            rhs[1] = qCr[iter+1]- bCr[iter+1];

            Info << "points:" << aCr[iter] << tab << aCr[iter+1] << endl;
            Info << "points:" << bCr[iter] << tab << bCr[iter+1] << endl;
            Info << "points:" << qCr[iter] << tab << qCr[iter+1] << endl;
            Info << "points:" << pCr[iter] << tab << pCr[iter+1] << endl;

	    if ((aCr[iter]==  qCr[iter]) && (aCr[iter+1]==qCr[iter+1]))
	    {

            detRhs = faceCross[0][0]*faceCross[1][1] - faceCross[1][0]*faceCross[0][1];
   
            detAij[0] = (rhs[0]*faceCross[1][1] - rhs[1]*faceCross[1][0])/detRhs ;
            detAij[1] = (rhs[1]*faceCross[0][0] - rhs[0]*faceCross[0][1])/detRhs ;

            // Now need to choose one coordinate and keep going with that, choosing the 
            // corresponding segment

	    //need to check if the third equation is satisfied:

	    double test=0.0;
            if (iter==0)
	    {
	    	test = detAij[0]*(aCr[iter+2]-bCr[iter+2])+detAij[1]*(qCr[iter+2]-pCr[iter+2])+bCr[iter+2]-qCr[iter+2];
	    }
	    else 
	    {
	    	test = detAij[0]*(aCr[iter-1]-bCr[iter-1])+detAij[1]*(qCr[iter-1]-pCr[iter-1])+bCr[iter-1]-qCr[iter-1];
	    }
    	    Info << "test after "<< tab  << iter << tab << test   << endl;
    	    Info << "Abs test"   << endl;
    	    Info << fabs(test)   << endl;

	 
	    if (fabs(test) < 1e-5)
	    {
		checkFace = true;

                center.x() = aCr.x()+detAij[0]*(bCr.x()-aCr.x());
                center.y() = aCr.y()+detAij[0]*(bCr.y()-aCr.y());
                center.z() = aCr.z()+detAij[0]*(bCr.z()-aCr.z());
	    } 
	}
//	}
//	else
//	{
//	    
//	    faceCross[0][0]= aCr[iter]-bCr[iter];
//            faceCross[1][0]= aCr[iter-2]-bCr[iter-2];
//
//            faceCross[0][1]= qCr[iter]-pCr[iter];
//            faceCross[1][1]= qCr[iter-2]-pCr[iter-2];
//
//            rhs[0] = qCr[iter]-  bCr[iter];
//            rhs[1] = qCr[iter-2]-bCr[iter-2];
//
//            detRhs = faceCross[0][0]*faceCross[1][1] - faceCross[1][0]*faceCross[0][1];
//
//            detAij[0] = (rhs[0]*faceCross[1][1] - rhs[1]*faceCross[1][0])/detRhs ;
//            detAij[1] = (rhs[1]*faceCross[0][0] - rhs[0]*faceCross[0][1])/detRhs ;
//
//            // Now need to choose one coordinate and keep going with that, choosing the
//            // corresponding segment
//
//
//            //need to check if the third equation is satisfied:
//
//            scalar test = detAij[0]*(aCr.y()-bCr.y())+detAij[1]*(qCr.y()-pCr.y())+bCr.y()-qCr.y();
//
//            if (abs(test)< 1e-5)
//            {
//                checkFace = true;
//
//                center.x() = aCr.x()+detAij[0]*(bCr.x()-aCr.x());
//                center.y() = aCr.y()+detAij[0]*(bCr.y()-aCr.y());
//                center.z() = aCr.z()+detAij[0]*(bCr.z()-aCr.z());
//
//            }
//	}

	iter++;	
    }

    ////Area of the triangles comprised between the impact point and two successive vertices
    //vectorField triFacetAreaImpact(deposits[faceI].size());
    //vectorField triFacetArea(deposits[faceI].size());

    ////as above, but normalized
    //vectorField triFacetUnitNormalVector(facets[faceI].size());
    //vectorField triFacetUnitNormalVectorImpact(facets[faceI].size());

    Info << "Triangulating ...." << endl;
    //Area of the triangles comprised between the impact point and two successive vertices
    vectorField   triFacetAreaImpact(4,Zero );
    vectorField 	triFacetArea(4,Zero );

    //as above, but normalized
    vectorField 	triFacetUnitNormalVector(4,Zero );
    vectorField   triFacetUnitNormalVectorImpact(4,Zero );

    Info << "facet center evaluated" << endl;
    Info << center.x() << tab << center.y() << tab <<center.z() << endl;

    for(label pointI=0; pointI < 4  ; pointI++ )
    {
	vector edge1	=Zero;	 
	vector edgeI2	=Zero; 
	vector edgeI3	=Zero; 
	vector edgeC1	=Zero;
	vector edgeC2	=Zero;

// Devo sostituire tutti le volte che appare facetPoints, l'equivalente Ã¨ auxGrid[facets[faceI][pointOfInterest]]

	
	if (pointI < 3)
	{
	   edge1  = auxGrid[facets[faceI][pointI+1]]-auxGrid[facets[faceI][pointI]];
	   edgeI2 = xyz - auxGrid[facets[faceI][pointI+1]];
	   edgeI3 = auxGrid[facets[faceI][pointI]] - xyz;
	   edgeC1 = center - auxGrid[facets[faceI][pointI+1]];
	   edgeC2 = auxGrid[facets[faceI][pointI]] - center;
	}
 	else	
	{
	   edge1  = auxGrid[facets[faceI][0]]-auxGrid[facets[faceI][pointI]];
           edgeI2 = xyz - auxGrid[facets[faceI][0]];
           edgeI3 = auxGrid[facets[faceI][pointI]] - xyz;
	   edgeC1 = center - auxGrid[facets[faceI][0]];
	   edgeC2 = auxGrid[facets[faceI][pointI]] - center;
	}

        Info << "Calculating normals ...." << endl;
        // Area of triangle (with sign) = crossProduct/2
        triFacetAreaImpact[pointI] = (edgeI2 ^ edgeI3)/2 ;
	Info << "Normal to triangle with impact" << tab << triFacetAreaImpact[pointI] << endl;

        triFacetArea[pointI] = (edgeC1 ^  edgeC2)/2 ;
	Info << "Normal to triangle with impact" << tab << triFacetArea[pointI] << endl;
	Info << "edge C1" << tab << edgeC1 << endl;
	Info << "edge C2" << tab << edgeC2 << endl;

        triFacetUnitNormalVectorImpact[pointI] 	= triFacetAreaImpact[pointI]/mag(triFacetAreaImpact[pointI]);
        triFacetUnitNormalVector[pointI] 	= triFacetArea[pointI]	    /mag(triFacetArea[pointI]);

        Info << "Calculating dotProds ...." << endl;
//	Info << "Normal to triangle with impact" << tab << triFacetUnitNormalVectorImpact[pointI] << endl;
//	Info << "Normal to triangle with center" << tab << triFacetUnitNormalVector[pointI] << endl;


        dotProds[pointI] = triFacetUnitNormalVector[pointI] & triFacetUnitNormalVectorImpact[pointI];
	
//	Info << "dot prod" << tab << dotProds[pointI]  << endl;

	facetArea[faceI] += mag(triFacetArea[pointI]);
	
//	Info << "Edges" << endl <<"edge1" << edge1 << endl << "edgeI2" << tab << edgeI2 << endl << "edgeI3" << tab << edgeI3  <<
//			   endl << "edgeC1" << tab << edgeC1 << endl << "edgeC2" << tab << edgeC2   << endl; 
	

    }


//	Info << "Area of facet" << tab << faceI << tab<< facetArea[faceI]<< endl;
//	Info << "Impact Point" << tab << xyz << endl;


        	

        if(std::all_of(dotProds.begin(), dotProds.end(), [](int a){return a>0;}))
	{//The point is inside the face
	facetHit = faceI;
            Info << "the point is inside the face" << endl;
	}	

}

// Need to update the deposit
scalar volume = p.mass()/rho;

std::string outfileName3 = "deposits.tmp";

ofstream outfile2 (outfileName3.c_str());

forAll(deposits,faceI)
{

    if(faceI==facetHit)
    {

	scalar displacement = volume / facetArea[faceI];
	deposits[faceI] += displacement;
	
    }

    outfile2  << std::fixed  << deposits[faceI]  ;
}

outfile2.close();

std::string infileName4 = ".deposits";

remove( infileName4.c_str());
rename( outfileName3.c_str(),infileName4.c_str());
