//piece of code that provides the mapping of the rectangular grid composed by the 
//facet centres to the boundaries
//the mapping is from a 2d rectangle to a 2d face arbitrarly oriented. Let's do it

scalar w=0;
scalar v=0;
scalar e0,e1=0;
scalar f0,f1=0;
scalar g0,g1=0;
scalar dx,dy,dz=0;

vector x0;
vector x1;
vector x2;

label nx = nDivisions;
label ny = nDivisions;

//need to build the borders

//lower border
x0.x() = newFacePoints[0].x();
x0.y() = newFacePoints[0].y();
x0.z() = newFacePoints[0].z();
x1.x() = newFacePoints[1].x();
x1.y() = newFacePoints[1].y();
x1.z() = newFacePoints[1].z();

dx= (x1.x()-x0.x())/nx;
dy= (x1.y()-x0.y())/nx;
dz= (x1.z()-x0.z())/nx;

for(label low=0; low <= nx; low ++)
{
   auxGrid[low].x() = x0.x()+ low * dx;
   auxGrid[low].y() = x0.y()+ low * dy;
   auxGrid[low].z() = x0.z()+ low * dz;

   Info  << auxGrid[low].x() << tab << auxGrid[low].y() <<tab << auxGrid[low].z() << endl;
}   

//upper 
x0.x() = newFacePoints[3].x();
x0.y() = newFacePoints[3].y();
x0.z() = newFacePoints[3].z();
x1.x() = newFacePoints[2].x();
x1.y() = newFacePoints[2].y();
x1.z() = newFacePoints[2].z();

dx= (x1.x()-x0.x())/nx;
dy= (x1.y()-x0.y())/nx;
dz= (x1.z()-x0.z())/nx;

label ind1=0;
for(label up = nx*(ny+1)+1 ; up <= (nx+1)*(ny+1); up ++)
{
   auxGrid[up].x() += x0.x() + ind1 * dx;
   auxGrid[up].y() += x0.y() + ind1 * dy;
   auxGrid[up].z() += x0.z() + ind1 * dz;
   Info  << auxGrid[up].x() << tab << auxGrid[up].y() <<tab << auxGrid[up].z() << endl;
   ind1++;
}   

//left
x0.x() = newFacePoints[3].x();
x0.y() = newFacePoints[3].y();
x0.z() = newFacePoints[3].z();
x1.x() = newFacePoints[0].x();
x1.y() = newFacePoints[0].y();
x1.z() = newFacePoints[0].z();

dx= (x1.x()-x0.x())/ny;
dy= (x1.y()-x0.y())/ny;
dz= (x1.z()-x0.z())/ny;

ind1=0;
for(label left = 0 ; left <= (nx+1)*ny +1; left += nx+1)
{

   auxGrid[left].x() = x0.x() + ind1 *dx;
   auxGrid[left].y() = x0.y() + ind1 *dy;
   auxGrid[left].z() = x0.z() + ind1 *dz;
   Info  << auxGrid[left].x() << tab << auxGrid[left].y() <<tab << auxGrid[left].z() << endl;
   ind1++;
}


//right
x0.x() = newFacePoints[1].x();
x0.y() = newFacePoints[1].y();
x0.z() = newFacePoints[1].z();
x1.x() = newFacePoints[2].x();
x1.y() = newFacePoints[2].y();
x1.z() = newFacePoints[2].z();

dx= (x1.x()-x0.x())/ny;
dy= (x1.y()-x0.y())/ny;
dz= (x1.z()-x0.z())/ny;

ind1=0;
for(label right = nx+1 ; right <= (nx+1)*(ny+1); right += nx+1)
{
   auxGrid[right].x() = x0.x() + ind1 *dx;
   auxGrid[right].y() = x0.y() + ind1 *dy;
   auxGrid[right].z() = x0.z() + ind1 *dz;
   Info  << auxGrid[right].x() << tab << auxGrid[right].y() <<tab << auxGrid[right].z() << endl;
   ind1 ++;
}

//for(label j=1 ; j<ny ; j++) //j<ny
//{
//
//   for(label i=1; i< nx; i++)
//   {
//	label h  =  i+ (nx+1)*(j);
//        label h1 = (nx+1)*j;
//        label h0 =  1+ (nx+1)*(j);
//        w=j-1 ;
//        w= w/nx;
//
//	auxGrid[h].x() =  auxGrid[h1].x() *w +(1-w)* auxGrid[h0].x();
//	auxGrid[h].y() =  auxGrid[h1].y() *w +(1-w)* auxGrid[h0].y();
//	auxGrid[h].z() =  auxGrid[h1].z() *w +(1-w)* auxGrid[h0].z();
//   }
//}


for(label j=1 ; j<ny ; j++) //j<ny
{

   for(label i=1; i< nx; i++)
   {
	label h  = i+ (nx+1)*(j)     ;
	label hlow = i; //j*(nx+1)   ;
	label hleft = (nx+1)*(j-1)+1 ;
	label hright = (nx+1)*(j-1)  ; 
	label hup = i+ (nx+1)*ny;

	vector r0(3,0.0) ;
	vector r1(3,0.0) ;
	vector r2(3,0.0) ;
	vector r3(3,0.0) ;
	vector r4(3,0.0) ;
	vector r5(3,0.0) ;
	vector r6(3,0.0) ;
	vector r7(3,0.0) ;


	w  = j-1;
	w  = w/ny;
	
	v  = i-1;
	v  = v/nx;

	r0 = auxGrid[hlow]*w + (1-w)*auxGrid[hup];
	r1 = auxGrid[hleft]*v + (1-v)*auxGrid[hright];
	
	//need to correct with the errors	
	e0 = v*w *auxGrid[0] + w*(1-v)*auxGrid[(nx+1)]
	e1 = v*(1-w) *auxGrid[1+(nx+1)*ny] + (1-w)*(1-v)*auxGrid[(nx+1)*(ny+1)]

	//Need to interpolate firstly the borders:along the x direction
	e0 = w*auxGrid[h1].x() + (1-w)* auxGrid[h0].x();
	e0 = auxGrid[h2].x()-e0;

	//Along y	
	f0 = w*auxGrid[h1].y()+ (1-w)* auxGrid[h0].y();
	f0 = auxGrid[h2].y()-f0;

	//Along z
  	g0 = w*auxGrid[h1].z()+ (1-w)* auxGrid[h0].z();
  	g0 = auxGrid[h2].z()-g0;
	
	h0 = 1+(nx+1)+ny;
	h1 = (nx+1)*(ny+1);
	h2 = i+(nx)*ny;
//	h2 = h0;

	e1 = v*auxGrid[h1].x()+ (1-v) * auxGrid[h0].x();
	e1 = auxGrid[h2].x()-e1;
	
	f1 = v*auxGrid[h1].y()+ (1-v)* auxGrid[h0].y();
	f1 = auxGrid[h2].y()-(f1);
	
  	g1 = v*auxGrid[h1].z()+ (1-v)* auxGrid[h0].z();
  	g1 = auxGrid[h2].z()-g1;

//	auxGrid[h].x() =  auxGrid[h].x() + w*e1+(1-w)*e0;
//	auxGrid[h].y() =  auxGrid[h].y() + w*f1+(1-w)*f0;
//	auxGrid[h].z() =  auxGrid[h].z() + w*g1+(1-w)*g0;

   	Info  << auxGrid[h].x() << tab << auxGrid[h].y() <<tab << auxGrid[h].z() << endl;

	
     }
}


// I have right now an auxiliary grid.
// What I need is the central point of the facet in order to assign to 
// this reference all the deposit. This way I am independent from the direction of the facet. Am I?




